<!doctype html>
<html>
<head>
    <base href="/">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="Ronald Zhao">

<meta name="description" content="">

<title>Python面试题收集整理</title>
<meta name="generator" content="Hugo 0.55.6" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/pojoaque.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
<link  href="https://ronaldzhao.top//css/theme.min.css" rel="stylesheet" type="text/css">

</head>
<body>
<div class="page-container container-fluid">
<div class="col-md-3 menu">
    <nav class="col-md-3">
    
    <h3 class="home-link"><a href="/">Root</a></h3>
    <div id="last-posts" class="open">
        <h3 data-open="last-posts">Ronald Zhao&#39;s Blog - Most recent posts</h3>
        <ul>
            
            <li><a href="https://ronaldzhao.top/posts/v2ray_client_config/">v2ray的客户端配置文件（Linux）</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/win10%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AEpypi%E6%BA%90/">Win10全局配置pypi源</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github/">将Hugo博客部署到Github</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/functools.wraps%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8/">functools.wraps装饰器的作用</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/python%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/">Python变量的作用域</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/python%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/">Python面试题收集整理</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/win10%E5%AE%89%E8%A3%85chocolatey%E5%92%8Cvim/">Win10安装Chocolatey和Vim</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/win10%E4%B8%8B%E5%AE%89%E8%A3%85mysql8.0.11.zip/">Win10下安装MySQL8.0.11</a></li>
            
            <li><a href="https://ronaldzhao.top/about/">About Me</a></li>
            
            <li><a href="https://ronaldzhao.top/posts/yield_from/">yield from</a></li>
            
        </ul>
    </div>
    

    
    <div id="tags" class="open">
        <h3 data-open="tags">Tags</h3>
        <ul class="tags">
            
            <li><a href="/tags/generator">generator</a></li>
            
            <li><a href="/tags/hugo">hugo</a></li>
            
            <li><a href="/tags/mysql">mysql</a></li>
            
            <li><a href="/tags/python">python</a></li>
            
            <li><a href="/tags/v2ray">v2ray</a></li>
            
            <li><a href="/tags/vim">vim</a></li>
            
            <li><a href="/tags/vs-code">vs-code</a></li>
            
            <li><a href="/tags/yield">yield</a></li>
            
        </ul>
    </div>
    

    
    <div id="categories" class="open">
        <h3 data-open="categories">Categories</h3>
        <ul class="categories">
            
            <li><a href="/categories/golang">golang</a></li>
            
            <li><a href="/categories/python">python</a></li>
            
            <li><a href="/categories/%E5%B7%A5%E5%85%B7">工具</a></li>
            
            <li><a href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a></li>
            
            <li><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
            
            <li><a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a></li>
            
        </ul>
    </div>
    
</nav>

</div>
<div class="col-md-9 content">

<h1>Python面试题收集整理</h1>
<h4>Published 04-20-2019 23:10:55</h4>

<a href="https://twitter.com/share" class="twitter-share-button" data-via="kendo5731"></a>
<script>!function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
    if (!d.getElementById(id)) {
        js = d.createElement(s);
        js.id = id;
        js.src = p + '://platform.twitter.com/widgets.js';
        fjs.parentNode.insertBefore(js, fjs);
    }
}(document, 'script', 'twitter-wjs');</script>

<div class="fb-share-button" data-href="https://ronaldzhao.top/posts/python%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/" data-layout="button"></div>
<div id="fb-root"></div>
<script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en-US/sdk.js#xfbml=1&version=v2.5";
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<article>
    

<h2 id="q-python这么好-说说它的特性吧">Q：python这么好，说说它的特性吧</h2>

<p>A：</p>

<ol>
<li>python是解释型语言。即：它不需要编译，变运行便捷式；</li>
<li>python是动态类型化的。即：当声明变量的时候，无需指定变量的类型；</li>
<li>python非常适合面向对象编程。即：它允许定义类以及组合和继承；</li>
<li>python没有访问修饰符；</li>
<li>python中函数是一等对象(第一类对象)。即：函数可以在运行时动态创建；函数可以赋值给变量；函数可以作为参数传递给函数；函数可以作为返回值从函数返回；</li>
<li>python容易上手，编码效率高，但比编译型语言运行速度慢。幸运的是，python允许包含基于C的扩展，所以瓶颈可以被优化掉。</li>
</ol>

<h2 id="q-python中对象的赋值-浅拷贝-深拷贝的区别">Q： python中对象的赋值、浅拷贝、深拷贝的区别</h2>

<p>A：</p>

<ol>
<li>对象的赋值</li>
</ol>

<p>python中对象的赋值实际上是简单的对象的引用。即：当创建一个对象并将其赋值给一个变量的时候，python并没有拷贝这个对象，只是简单的把这个对象的引用赋值给变量。</p>

<pre><code class="language-python">&gt;&gt;&gt; list1 = [1,2,3,4]
&gt;&gt;&gt; list2 = list1
&gt;&gt;&gt; print(list1, id(list1))
[1, 2, 3, 4] 4552843656
&gt;&gt;&gt; print(list2, id(list2))
[1, 2, 3, 4] 4552843656
&gt;&gt;&gt; list1.append(5)
&gt;&gt;&gt; print(list1, id(list1))
[1, 2, 3, 4, 5] 4552843656
&gt;&gt;&gt; print(list2, id(list2))
[1, 2, 3, 4, 5] 4552843656
</code></pre>

<ol>
<li>浅拷贝</li>
</ol>

<p>一般使用<code>copy.copy()</code>可以进行对象的浅拷贝。但对于对象中的元素，它仍然使用原始的引用。</p>

<pre><code class="language-python">&gt;&gt;&gt; import copy
&gt;&gt;&gt; list1 = [1,2,3,4, [5,6,7,8]]
&gt;&gt;&gt; print(list1, id(list1))
[1, 2, 3, 4, [5, 6, 7, 8]] 4322790536
&gt;&gt;&gt; list2 = copy.copy(list1)
&gt;&gt;&gt; print(list2, id(list2))
1, 2, 3, 4, [5, 6, 7, 8]] 4322790792
&gt;&gt;&gt; list1.append(9)
&gt;&gt;&gt; print(list1, id(list1))
[1, 2, 3, 4, [5, 6, 7, 8], 9] 4322790536
&gt;&gt;&gt; print(list2, id(list2))
1, 2, 3, 4, [5, 6, 7, 8]] 4322790792
&gt;&gt;&gt; list1[4].append(10)
&gt;&gt;&gt; print(list1, id(list1))
[1, 2, 3, 4, [5, 6, 7, 8, 10], 9] 4322790536
&gt;&gt;&gt; print(list2, id(list2))
[1, 2, 3, 4, [5, 6, 7, 8, 10]] 4322790792
</code></pre>

<p>使用<code>copy.copy()</code>对<code>list1</code>浅拷贝到<code>list2</code>，<code>list2</code>复制了<code>list1</code>的对象，但是<code>list2</code>里面的<code>[5,6,7,8]</code>和<code>list1</code>里面的<code>[5,6,7,8]</code>其实都是指向<strong>同一块内存地址</strong>，所以改变了<code>list1[4]</code>后<code>list2[4]</code>也会发生改变。</p>

<ol>
<li>深拷贝</li>
</ol>

<p>深拷贝需要使用<code>copy.deepcopy()</code>函数。它会复制一个容器对象，以及它里面的所有元素(包含元素的子元素，即递归复制)。</p>

<p>当对<code>list1</code>列表进行深拷贝之后，<code>list2</code>复制了<code>list1</code>对象，但是与浅拷贝不同的是，<code>list2</code>里面的<code>[5,6,7,8]</code>与<code>list1</code>里面的<code>[5,6,7,8]</code>是指向<strong>不同的内存地址</strong>。</p>

<h2 id="q-python中-和-is-的区别">Q：python中 == 和 is 的区别</h2>

<p>A：</p>

<p><code>is</code>判断对象标识符是否一致，而<code>==</code>是判断两个对象的内容是否相等。<code>x is y</code>相当于<code>id(x) == id(y)</code>；<code>==</code>会调用对象内部的<code>__eq__()</code>检查两个对象的内容是否相等。</p>

<h2 id="q-如何在python中实现多线程">Q：如何在python中实现多线程</h2>

<p>A：</p>

<p>python中有一个多线程包<code>threading</code>可以用来实现多线程。但同时Python中有一个<code>GIL(Global Interpreter Lock，全局解释器锁)</code>，它确保在任何时刻只有一个线程可以执行。</p>

<p>线程获取<code>GIL</code>，做一些工作，然后将<code>GIL</code>传递到下一个线程。这种情况发生的非常快，所以对于人眼而言，它可能看起来像所有线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在使得Python中的多线程无法真正的利用多核的优势来提高性能。</p>

<p>对于IO密集型操作，在等待操作系统返回的时候会释放GIL。比如爬虫因为有等待服务器的响应时间，可以利用多线程来加速；但是对于CPU密集型操作，只能通过多进程<code>multiprocess</code>来加速。</p>

<h2 id="q-python中的猴子补丁是什么">Q：Python中的猴子补丁是什么</h2>

<p>A：</p>

<p>猴子补丁，是一种非常Pythonic的用法。即函数在Python中可以像使用变量一样对它们进行赋值等操作，我们可以在运行时替换模块，这种手法俗称<code>猴子补丁</code>。</p>

<h2 id="q-python中的-new-和-init-的区别">Q：Python中的 <strong>new</strong> 和 <strong>init</strong> 的区别</h2>

<p>A：</p>

<p><code>__init__</code>为初始化方法，而<code>__new__</code>方法才是真正的构造函数。只有继承了<code>object</code>的类才有<code>__new__</code>。</p>

<p><code>__new__</code>至少要有一个参数<code>cls</code>，代表要实例化的类，此参数在实例化时由Python解释器自动提供。<code>__new__</code>必须要有返回值，返回实例化出来的实例。</p>

<p><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>返回的实例。先运行<code>__new__</code>然后才运行<code>__init__</code>。</p>

<p><code>__init__</code>在<code>__new__</code>的基础上可以完成一些其他初始化的动作。<code>__init__</code>不需要返回值。</p>

<hr />

<h2 id="1-类继承">1.类继承</h2>

<p>问题：有如下一段代码，请问应该如何调用<code>A</code>的<code>show</code>方法？</p>

<pre><code class="language-python">class A(object):
    def show(self):
        print('base show')
class B(A):
    def show(self):
        print('derived show')
obj = B()
obj.show()
</code></pre>

<p>答案：</p>

<pre><code class="language-python">obj.__class__ = A
obj.show()
</code></pre>

<p>解释：</p>

<p><code>__class__</code>方法指向了类对象，只要给他赋值类型<code>A</code> ，然后调用方法<code>show</code>，但是用完了记得修改回来。</p>

<h2 id="2-方法对象">2.方法对象</h2>

<p>问题：为了让下面这段代码运行，需要增加那些代码？</p>

<pre><code class="language-python">class A(object):
    def __init__(self, a, b):
        self.__a = a
        self.__b = b
    def myprint(self):
        print('a=', self.__a, 'b=', self.__b)

a1 = A(10, 20)
a1.myprint()

a1(80)
</code></pre>

<p>答案：为了能让对象实例能被直接调用，需要实现<code>__call__</code>方法：</p>

<pre><code class="language-python">class A(object):
    def __init__(self, a, b):
        self.__a = a
        self.__b = b
    def myprint(self):
        print('a=', self.__a, 'b=', self.__b)
    def __call__(self, num):
        print('call:', num + self.__a)
</code></pre>

<h2 id="3-new和init">3.new和init</h2>

<p>问题：下面这段代码输出什么？</p>

<pre><code class="language-python">class B(object):
    def fn(self):
        print('B fn')
    def __init__(self):
        print('B INIT')


class A(object):
    def fn(self):
        print('A fn')
    def __new__(cls, a):
        print('NEW', a)
        if a &gt; 10:
            return super(A, cls).__new__(cls)
        return B()
    def __init__(self, a):
        print('INIT', a)

a1 = A(5)
a1.fn()
a2 = A(20)
a2.fn()
</code></pre>

<p>答案：</p>

<pre><code class="language-python">NEW 5
B INIT
B fn
NEW 20
INIT 20
A fn
</code></pre>

<p>解释：</p>

<p>使用<code>__new__</code>方法，可以决定返回哪个对象，也就是创建对象之前。这个可以用于设计模式的单例模式、工厂模式。<code>__init__</code>是创建对象用来调用的。</p>

<h2 id="4-list和dict生成">4.list和dict生成</h2>

<p>问题：下面这段代码输出什么？</p>

<pre><code class="language-python">ls = [1, 2, 3, 4]
list1 = [i for i in ls if i &gt; 2]
print(list1)

list2 = [i * 2 for i in ls if i &gt; 2]
print(list2)

dic1 = {x:x**2 for x in (2, 4, 6)}
print(dic1)

dic2 = {x:'item'+str(x**2) for x in (2, 4, 6)}
print(dic2)

set1 = {x for x in 'hello world' if x not in 'low level'}
</code></pre>

<p>答案：</p>

<pre><code class="language-python">[3, 4]
[6, 8]
{2: 4, 4: 16, 6: 36}
{2: 'item4', 4: 'item16', 6: 'item36'}
set(['h', 'r', 'd'])
</code></pre>

<h2 id="5-全局变量和局部变量">5.全局变量和局部变量</h2>

<p>问题：下面这段代码输出什么？</p>

<pre><code class="language-python">num = 9

def f1():
    num = 20

def f2():
    print(num)

f2()
f1()
f2()
</code></pre>

<p>答案：</p>

<pre><code class="language-python">9
9
</code></pre>

<p>解释：</p>

<p><code>num</code>看似是个全局变量，实则不是，所以<code>f1</code>函数中的<code>num</code>实际上是这个函数自己的<code>num</code>，与函数外部的<code>num</code>没有关系。如果想在<code>f1</code>函数内部修改函数外部的<code>num</code>的话，则需要使用<code>global</code>关键字修饰<code>num</code>：</p>

<pre><code class="language-python">def f1():
    global num
    num = 20
</code></pre>

<p>这样才能达到在函数内部修改外部的变量的目的。</p>

<h2 id="6-交换两个变量的值">6.交换两个变量的值</h2>

<p>问题：用一行代码交换两个变量的值。</p>

<pre><code class="language-python">a = 8
b = 9
</code></pre>

<p>答案：<code>a, b = b, a</code></p>

<h2 id="7-默认方法">7.默认方法</h2>

<p>问题：有如下的代码：</p>

<pre><code class="language-python">class A(object):
    def __init__(seld, a, b):
        self.a1 = a
        self.b1 = b
        print('init')
    def mydefault(self):
        print('default')

a1 = A(10, 20)
a1.fn1()
a1.fn2()
a1.fn3()
</code></pre>

<p>其中，方法<code>fn1</code>、<code>fn2</code>、<code>fn3</code>都没有定义。添加代码，使没有定义的方法都调用<code>mydefault</code>函数，使得上面的代码输出：</p>

<pre><code class="language-python">default
default
default
</code></pre>

<p>答案：</p>

<pre><code class="language-python">class A(object):
    def __init__(self, a, b):
        self.a1 = a
        self.b1 = b
        print('init')
    def mydefault(self):
        print('default')
    def __getattr__(self, name):
        return self.mydefault

a1 = A(10, 20)
a1.fn1()
a1.fn2()
a1.fn3()
</code></pre>

<p>解释：</p>

<p>方法<code>__getattr__</code>只有当调用了没有定义的方法的时候才会调用它。当<code>fn1</code>方法传入参数时，我们可以给<code>mydefault</code>方法增加一个<code>*args</code>不定参数来兼容：</p>

<pre><code class="language-python">class A(object):
    def __init__(self, a, b):
        self.a1 = a
        self.b1 = b
        print('init')
    def mydefault(self, *args):
        print('default' + str(args[0]))
    def __getattr__(self, name):
        return self.mydefault

a1 = A(10, 20)
a1.fn1()
a1.fn2()
a1.fn3()
</code></pre>

<h2 id="8-包管理">8.包管理</h2>

<p>问题：一个包里有三个模块，<code>mod1.py</code>、<code>mod2.py</code>、<code>mod3.py</code>，但使用<code>from demopack import *</code>导入模块时，如何保证只有<code>mod1</code>、<code>mod3</code>被导入了。</p>

<p>答案：在<code>demopack</code>包中的<code>__init__</code>文件中增加：</p>

<pre><code class="language-python">__all__ = ['mod', 'mod3']
</code></pre>

<h2 id="9-闭包">9.闭包</h2>

<p>问题：写一个函数，接收整数参数<code>n</code>，返回一个函数，函数的功能是把函数的参数和<code>n</code>相乘并把结果返回。</p>

<p>答案：</p>

<pre><code class="language-python">def nulby(num):
    def gn(val):
        return num * val
    return gn

zw = nulby(7)
print(zw(9))  # 输出 63
</code></pre>

<h2 id="10-性能">10.性能</h2>

<p>问题：解析下面的代码慢在哪？</p>

<pre><code class="language-python">def strtest1(num):
    str = 'first'
    for i in range(num):
        str += '×'
    return str

</code></pre>

<p>答案：</p>

<p><code>python</code>的<code>str</code>是个不可变对象，每次迭代，都会生成新的<code>str</code>对象来存储新的字符串，<code>num</code>越大，创建<code>str</code>对象的次数越多，内存消耗越大。</p>

<h2 id="参考文章">参考文章</h2>

<p><a href="https://juejin.im/post/5abd9f9ef265da239d496874">精心整理的8道Python面试题，你答不答的出来</a>
<a href="https://segmentfault.com/a/1190000012277531">原文来源</a></p>

</article>



</div>
</div>
<script src="https://ronaldzhao.top//js/theme.min.js" type="text/javascript"></script>


</body>
</html>

